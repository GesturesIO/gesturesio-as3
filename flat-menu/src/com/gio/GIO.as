package com.gio {	import flash.display.Sprite;	import flash.geom.Point;	import flash.net.Socket;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.DataEvent;	import flash.events.EventDispatcher;	import flash.utils.ByteArray;	import flash.utils.getTimer;	import flash.events.ProgressEvent;	import flash.system.Capabilities;	/**	 * THIS IS A SINGLETON	 * @author Gestures.IO	 */	public class GIO extends Sprite	{		private var socketClientId:String;		private static var _instance:GIO;		private static var _allowInstance:Boolean;		private var GIOSocket:Socket;		private var MacPingPolicyFileSocket:Socket;		private var windowW:Number;		private var windowH:Number;		private var status:uint = 2;		private var scaleWinX:Number;		private var scaleWinY:Number;		private var users:Vector.<GIOUser>;		private var messagesQueue:Vector.<GIOMessage> = new Vector.<GIOMessage>();		private var messagesQueueMemory:Vector.<GIOMessage> = new Vector.<GIOMessage>();		private var portNumber:int;		public function GIO() 		{			if (!GIO._allowInstance)			{				throw new Error("Error: Use MediaStanza.getInstance() instead of the new keyword.");			}		}		// singleton instance of GIO		public static function getInstance():GIO		{			if (GIO._instance == null)			{				GIO._allowInstance = true;				GIO._instance = new GIO();				GIO._allowInstance = false;			}			return GIO._instance;		}		public function stopListeners():void {			GIOSocket.removeEventListener(Event.CONNECT, GIOSocketHandler);			GIOSocket.removeEventListener(Event.CLOSE, GIOSocketHandler);			GIOSocket.removeEventListener(IOErrorEvent.IO_ERROR, GIOSocketHandler);			GIOSocket.removeEventListener(ProgressEvent.SOCKET_DATA, GIOSocketDataHandler);		}		public function Init(windowW:Number, windowH:Number, portNumber:int = 1234):void {			this.portNumber = portNumber;			rescaleStage(windowW, windowH);				var whichOs:String = Capabilities.os;			if (whichOs.substring(0,3) == "Mac") {				pingMacPolicyFile();			} else {				startSocketService();			}		}		private function pingMacPolicyFile():void {			MacPingPolicyFileSocket = new Socket();			MacPingPolicyFileSocket.connect("localhost", 8087);			MacPingPolicyFileSocket.addEventListener(Event.CONNECT, MacPingPolicyFileSocketHandler);		}		private function MacPingPolicyFileSocketHandler(event:Event):void {			MacPingPolicyFileSocket.removeEventListener(Event.CONNECT, MacPingPolicyFileSocketHandler);			MacPingPolicyFileSocket.close();			startSocketService();		}		private function startSocketService():void {			GIOSocket = new Socket();			GIOSocket.connect("localhost", portNumber);			GIOSocket.addEventListener(Event.CONNECT, GIOSocketHandler);			GIOSocket.addEventListener(Event.CLOSE, GIOSocketHandler);			GIOSocket.addEventListener(IOErrorEvent.IO_ERROR, GIOSocketHandler);			GIOSocket.addEventListener(ProgressEvent.SOCKET_DATA, GIOSocketDataHandler);			users = new Vector.<GIOUser>();			var UTCdate:Date = new Date();			var randomToken:int = int((999 * Math.random()));			var year:String = normalizeToNChars(UTCdate.fullYearUTC.toString(), 4);			var numMonth:Number = UTCdate.monthUTC + 1;			var month:String = normalizeToNChars(numMonth.toString(), 2);			var numDay:Number = UTCdate.dayUTC + 1;			var day:String = normalizeToNChars(numDay.toString(), 2);			var hour:String = normalizeToNChars(UTCdate.getHours().toString(), 2);			var minutes:String = normalizeToNChars(UTCdate.getMinutes().toString(), 2);			var seconds:String = normalizeToNChars(UTCdate.getSeconds().toString(), 2);			var milliSeconds:String = normalizeToNChars(UTCdate.getMilliseconds().toString(), 4);			var randomTokenString:String = getTimer().toString();			randomTokenString += randomToken.toString();			socketClientId = year + month + day + hour + minutes + seconds + milliSeconds + randomTokenString;		}		private function normalizeToNChars(inputString:String, n:int):String {			var outputString:String = inputString;			var nbChars:int = inputString.length;			for (var i:int = 0; i < (n -nbChars); i++) {				outputString = "0" + outputString;			}			return (outputString);		}		public function activateGestureDetection(whichGesture:String , whichJoint:String, whichCoordinate:String = "", whichDirection:int = 0,whichUser:uint = 0) :void {			messagesQueue.push(new GIODataMessage(whichGesture, whichJoint, whichCoordinate , whichUser,whichDirection ));		}		public function inhibitGestureDetection(whichGesture:String , whichJoint:String, whichCoordinate:String = "", whichDirection:int = 0,whichUser:uint = 0) :void {			messagesQueue.push(new GIODataMessage("stop_" + whichGesture, whichJoint, whichCoordinate , whichUser,whichDirection ));		}		public function activateFilter(whichJoint:String, whichCoordinate:String, whichUser:uint = 0):void {			messagesQueue.push(new GIODataMessage("activateFilter", whichJoint, whichCoordinate, whichUser ));		}		public function removeFilter(whichJoint:String, whichCoordinate:String, whichUser:uint = 0):void {			messagesQueue.push(new GIODataMessage("removeFilter", whichJoint, whichCoordinate, whichUser ));		}		public function sendServiceMessage(theObject:Object):void {			messagesQueue.push(new GIOServiceMessage(theObject));		}		private function returnUserIndex(trackingID:int):int {			var indexUser:int = -1;			for (var i:int = 0; i < users.length; i++) {				if (users[i].trackingID == trackingID) {					indexUser = i;					break;				}			}			return (indexUser);		}		private function GIOSocketDataHandler(event:ProgressEvent):void		{			while(GIOSocket.bytesAvailable > 0)			{				try				{					var message:Object = GIOSocket.readObject();					var theObject:Object = message.data;					var i:int;					var currentUsersTrackingIDs:Vector.<int> = new Vector.<int>;					var indexUser:int;					var gIOEvent:GIOEvent;									if ((message.command == "SKELETON_UPDATE") && (theObject.length != 0)) {						status = 1;						for (i = 0; i < theObject.length; i++) {							indexUser = returnUserIndex(theObject[i].trackingID);							if (indexUser == -1) {								users.push(new GIOUser(theObject[i].trackingID));								indexUser = users.length -1;							}							users[indexUser].updateJoints(theObject[i].joints);							currentUsersTrackingIDs.push(theObject[i].trackingID);						}					} else if (message.command == "SKELETON_UPDATE") {						status = 0;					} else if (message.command == "GESTURE") {						gIOEvent = new GIOEvent(message.command, theObject);						this.dispatchEvent(gIOEvent);					} else if (message.command == "serviceMessage") {						gIOEvent = new GIOEvent(message.command, theObject);						this.dispatchEvent(gIOEvent);					}					cleanUpUsers(currentUsersTrackingIDs);				}				catch(e:Error)				{				}			}		}		private function cleanUpUsers(currentUsersTrackingIDs:Vector.<int>):void {			var i:int;			var j:int;			var isCurrent:Boolean;			var nbUsers:int = users.length - 1;			for (i = nbUsers; i >= 0; i--) {				isCurrent = false;				for (j = 0; j < currentUsersTrackingIDs.length; j++) {					if (users[i].trackingID == currentUsersTrackingIDs[j]) {						isCurrent = true;						break;					}				}				if (isCurrent == false) {					users[i].nullify();					users.splice(i, 1);				}			}		}		public function rescaleStage(windowW:Number, windowH:Number):void {			this.windowW = windowW;			this.windowH = windowH;			var cropW:Number = 400;			var cropH:Number = 300;			scaleWinX = windowW / cropW;			scaleWinY = windowH / cropH;		}		public function updateGIOSocket():String {						var returnVal:String = "";			var i:int;			switch(status)			{			 case 1:				returnVal = "data";				break;			 case 0:				returnVal = "nodata";				break;			 case 2:				 returnVal = "notconnected";				 break;			 default:				trace("None of the above were met");			}			return (returnVal);		}		public function getJointPosition(whichJoint:String, whichUser:uint = 0):GIO3DPoint {			var joint3DPoint:GIO3DPoint = new GIO3DPoint();			if (whichUser < users.length) {				var joint:GIOJoint = users[whichUser].joints[whichJoint];				if (joint != null) {					joint3DPoint = new GIO3DPoint(windowW * joint.x,windowH * joint.y,joint.z);				}			}			return (joint3DPoint);		}		private function GIOSocketHandler(event:Event):void {			switch (event.type) {				case 'ioError' :					trace("Can't connect.");					status = 2;					break;				case 'connect' :					if (messagesQueue.length > 0) {						var i:int;						for (i = 0 ; i < messagesQueue.length; i++) {							GIOSocket.writeObject(messagesQueue[i]);							GIOSocket.flush();							messagesQueueMemory.push(messagesQueue[i]);						}						messagesQueue = new Vector.<GIOMessage>();					}					status = 0;					break;				case 'close' :					trace("Closed.");					status = 2;					break;			}		}			// getter setter		public function get gIOStatus():Number { return (status) ; }		public function get clientId():String { return (socketClientId) ; }		public function get windowHeight():Number { return (windowH) ; }		public function get windowWidth():Number { return (windowW) ; }		public function get scaleWindowY():Number { return (scaleWinY) ; }		public function get scaleWindowX():Number { return (scaleWinX) ; }		public function set scaleWindowY(_scaleWinY:Number):void { scaleWinY = _scaleWinY; }		public function set scaleWindowX(_scaleWinX:Number):void { scaleWinX = _scaleWinX; }	}}